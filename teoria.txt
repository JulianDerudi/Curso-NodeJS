##############################  CLASE 2  ##############################

[[[  Single-Threading vs Multi-Threading  ]]]

Single-Threading: (modelo que usa Node.js)
    * Un hilo principal con event loop.
    * Delega tareas bloqueantes.
    * Altamente escalable.

Multi-Threading:
    * Multiples hilos simultaneo
    * Ideal para tareas de CPU intensivas
    * Mas complejo


Documentacion OFICIAL DE Node.js: 
    https://nodejs.org/en/learn/getting-started/introduction-to-nodejs



##############################  CLASE 3  ##############################

[[[  Tipos de Declaraciones de Funciones  ]]]

Funciones Declaradas:
    function search() {
        // proceso encapsulado
    }

Funciones Expresadas:
    const search = function () {
        // proceso encapsulado
    }

Arrow Functions:
    const search = () => {
        // proceso encapsulado
    }


[[[  Higher Order Functions (HOF) o callbacks  ]]]

// Donde la funciones son pasadas por parametro 

function calculator(a, b, action) {
    return action(a,b);
}

console.log(calculator(20, 10, (a, b) => a + b)); // 30


[[[  ARRAYS  ]]]

Metodos de array: 
    * arrayName[index]: para acceder a elementos precisos.
    * .lenght: para la longitud.
    * Push y Unshift: añaden elementos al inicio y final.
    * Pop y Shift: eliminan elementos del inicio y final.
    * .join(): une elementos de un array en una cadena.
    * .map(): crea un nuevo array con los resultados de una funcion.
    * .filter(): crea un nuevo array con elementos que pasan una prueba.
    * .reduce(): reduce un array a un solo valor acumulado.

Iteracion de array:
    * ForEach: ejecuta una función para cada elemento del array.
    * For...of: permite recorrer elementos de forma mas sencilla que un for tradicional.


[[[  TEMPLATE LITERALS  ]]]

// Cadenas de texto que permiten expresiones incrustadas.
// se usan backticks (`) y permite insertar variables usando ${expresión}.


[[[ GUIAS ]]]

Sobre funciones, arrays y template literals: MDN Web Docs
Libro interactivo para profundizar estos conceptos: Eloquent JavaScript



##############################  CLASE 4  ##############################

[[[  OBJETOS  ]]]
* Objetos literal:
        const hero = {
            alias: 'Cody',
            powers: ['fly', 'nightvision', 'stregth'],
            vitality: 100,
            drecreaseVitality: function(damage) {
                return this.vitality - damage
            }
        }

        hero.alias = 'Julian' //Cambiar valor
        hero[alias] = 'Julian' //Cambiar valor
        delete hero.alias //eliminar campo


* Objeto Funcional:
        function Hero(alias, vitality) {
            this.alias = alias;
            this.vitality = vitality;

            this.drecreaseVitality = function(damage) {
                return this.vitality - damage
            };
        }

        const hero = new Hero('Cody', 100); //Recien acá tengo el objeto literal


[[[  CLASES  ]]]
class Hero {
    constructor(alias, vitality) {
        this.alias = alias;
        this.vitality = vitality;
    }

    drecreaseVitality(damage) {
        return this.vitality - damage
    };
}

const hero = new Hero('Cody', 100);


[[[  HERENCIA  ]]]
class Super extends Hero {
    constructor(alias, vitality, power){
        super(alias, vitality);
        this.power = power;
    }
}


[[[  OPERADORES AVANZADOS  ]]]
* Destructuring Operator:
    const user = [1, 'Juan', 33, 'admin'];

    const [id, nombre, edad, rol] = user;

* Spread Operator:
    // con ARRAY
    const numeros = [1, 2, 3];
    const letras = ['a', 'b', 'c'];

    // const array = numeros.concat(letras);
    const array = [...numeros, ...letras];
    //            [1, 2, 3, 'a', 'b', 'c'];


    // con OBJETOS
    const viejoProducto = {id:1, nombre:"peruano"};
    const nuevoProducto = {precio:120, nombre:"peruanoide"};

    const producto = {...viejoProducto, ...nuevoProducto};
    //               {id:1, precio:120, nombre:"peruanoide"};




##############################  CLASE 5  ##############################

[[[  NPM  ]]]
* Gestion de Paquetes
* Configuracion de Proyectos
* Scripts Personalizados

// Modulos Externos
$npm install [paquete]
$npm update [paquete]
$npm uninstall [paquete]

// Modulos Nativos
- Como 'fs', 'http', etc.

// Modulos Internos
- nuestros propios modulos


[[[  CommonJS vs ES Modules  ]]]
* CommonJS:
    - Utiliza 'require()' y 'module.exports'.
        + const cowsay = require("cowsay");
        + const { say } = require("cowsay");
    - Es síncronico y compatible con Node.js.

* ES Modules:
    - Usa 'import' y 'export'.
        + import cowsay from "cowsay";
        + import { say } from "cowsay";
    - Es asíncronico y estandar en JavaScript moderno.


[[[  Dirname  ]]]
* el path actual
    ________________________________________________________
    | En html:
    | 
    | "./img/foto.jpg"             EXPLICACION DE AGUS CODE
    | 
    | En node.js:
    | 
    | rutaFoto = path.join(__dirname, "img", "foto.jpg");
    |_______________________________________________________

* en CommonJS: __dirname
* en Module: es mas complicado
    import { dirname } from "node:path";
    import { fileURLToPath } from "node:url";

    const __filename = fileURLToPath(import.meta.url);  //path
    const __dirname = dirname(__filename);

[[[  Rutas  ]]]





##############################  CLASE 6  ##############################

[[[  Asíncronismo  ]]]
Es un paradigma que permite ejecutar tareas en segundo plano sin bloquear el programa principal.
JavaScript: Lenguaje basado en eventos que utiliza callbacks, promesas y async/await.


[[[  Single Thread en JavaScript  ]]]
* Ejecución Secuencial: JavaScript ejecuta tareas en una sola secuencia de comandos.
* Event Loop: Maneja la cola de tareas para ejecutar operaciones asincrónicas.
* Call Stack: Estructura que registra las funciones en ejecución.


[[[  Callback Queue  ]]]
(Llamado a funciones en segundo plano)
* Almacenamiento: Guarda funciones callback y resultados de tareas asincrónicas.
* Ejecución: El Event Loop ejecuta las funciones cuando el Call Stack está vacío.
* Ejemplo: Consultas a APIs externas se manejan en la Callback Queue.


[[[  Callback  ]]]
* Funcion que cuando termina ejecuta otra funcion (pasada por parametro).
* Ejemplo:
        const fs = require("fs");

        console.log("algo");                                  //se ejecuta primero
        fs.readFile("./data.txt", "utf8", (error, data) => {  //se ejecuta ultimo
            console.log("error");
            console.log("data");
        });
        console.log("algo");                                  //se ejecuta segundo



[[[  Promesas  ]]]
* Ejemplo:
        const promesa = new Promise((resolve, reject) => {  // O se resuelve, o se rechaza
            if(algo) {
                resolver("Resuelto");
            } else {
                reject("Rechazado");
            }
        });

        promesa
            .then((response) => {      // Si la promesa resuelve va por acá
                console.log(response);
            })
            .catch((error) => {
                console.error(error);  // Si la promesa rechaza va por acá
            })
            .finally(() => console.log("Siempre se ejecuta"));



[[[  Fetch  ]]]
fetch("https://fakestoreapi.com/products")
    .then((res) => {res})
    .catch((error) => {error})
    .finally(() => {algo});



[[[  Async/Await  ]]]
* asincrónica no bloqueante
* Ejemplo:
        const respuesta = await fetch("https://fakestoreapi.com/products");  
                    //el await espera a que se resuelva la promesa y luego pasa la resolucion o rechazo (no bloquea)

* Catch para el Async/Await: 
        try {
            const respuesta = await fetch("https://fakestoreapi.com/products"); 
            const data = await respuesta.json();   // si no pongo await aca va a aparecer como que esta pendiente el resultado
            console.log(data);
        } catch (error) {
            console.log(error);
        }




##############################  CLASE 7  ##############################

* TCP, IP, DNS, Modelo CLiente/Servidor, HTTP(protocolo de comunicacion)

##############################  CLASE 8  ##############################

* mas cosas teoricas

##############################  CLASE 9  ##############################

* CREAR UN SERVIDOR 
    import http from "http";

    const server = http.createServer((req, res) => {
        console.log(req);                            // nomas para mostrarlo
        res.statusCode = 200;                        // todo OK
        res.setHeader("Content-Type", "text/plain"); // "Cambia el tipo de contenido por texto plano"
        res.end("Hola desde HTTP");                  // Corta comunicacion
    });

    const PORT = 3000;

    server.listen(PORT, () => console.log(`http://localhost:${PORT}`));




##############################  CLASE 10  ##############################

* MODELADO DE API REST

>>>>> carpeta "apirest" <<<<<

* ROUTES:
    - Las rutas se construyen combinando una URL específica con un método HTTP.

* CONTROLLERS:
    - Son los responsables de manejar la lógica que conecta las rutas con el resto 
      de la aplicación, actuando como un puente entre las solicitudes del cliente y 
      los datos o servicios que necesitamos usar.

* MODELO:
    - Todo el manejo de datos, son como los planos de una máquina: describen la 
      estructura de los datos y su interacción con la base de datos.

* SERVICE:
    - Un intermedio entre los controladores y los modelos